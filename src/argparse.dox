/**
\mainpage argparse

This library parses arguments as options, option-arguments and
operands according to POSIX 1003.1:

http://pubs.opengroup.org/onlinepubs/9699919799/

Given this code:
\code
    option *opt = option_new();
    opt->short_opt = "f";
    opt->long_opt = "feature";
\endcode

The following arguments are all parsed into opt:
    * -f
    * +f
    * --feature
    * --enable-feature
    * --disable-feature
    * --no-feature
    * --with-feature
    * --without-feature

Argparse does not provide a way to `link` options as mutually exclusive
or to set the same value. It is encouraged to make use of the
functionality above, otherwise this logic has to be implemented
separately.

As a convenience it is also possible to print descriptions of the
options to a stream.

Example:
    \code
    #include <argparse.h>
    #include <stdio.h>
    #include <stdlib.h>

    int main(size_t argc, char **argv) {
        args *args = args_new();
        if (!args) {
            fprintf(stderr, "argparse could not be initialized, aborting.\n");
            return EXIT_FAILURE;
        }

        option *opt = option_new();
        if (!opt) {
            fprintf(stderr, "option could not be initialized, aborting.\n");
            return EXIT_FAILURE;
        }

        opt->description = "do not output the trailing newline";
        opt->short_opt = "n";
        args_add_opt(args, opt);

        // the pointer can be reused as args_free() takes care of
        // freeing everything correctly
        opt = option_new();
        if (!opt) {
            fprintf(stderr, "option could not be initialized, aborting.\n");
            return EXIT_FAILURE;
        }

        opt->description = "enable interpretation of backslash escapes";
        opt->short_opt = "e";
        arg_add_opt(args, opt);

        // pass command line arguments (without the leading $0) to let
        // argparse parse them
        args_parse(args, argc - 1, argv[1]);

        // option_find returns the option-struct which represents the flag,
        // the parameter can be the short as well as the long option
        opt = option_find("e")
        bool interpret_escapes = false;
        if (opt->present > 0)
            // The `> 0` is important since opt->present could be
            // negative, if an argument `+e` was passed.
            interpret_escapes = true;

        bool trailing_newlinew = true;
        if (opt_find("n")->present > 0)
            trailing_newline = false;

        // frees args and opts recursively, no need to keep track of
        // them
        args_free(args);
    }
    \endcode
*/
